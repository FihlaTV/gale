StGermain Framework. Copyright (C) 2003-2005 VPAC.
StGermain Discretisation Library. Copyright (C) 2003-2005 VPAC.
StGermain FEM Discretisation Framework. Copyright (C) 2003-2005 VPAC.
Watching rank: 2

***  REGULAR node/element layout tests ***

***  Corner Node layout tests ***

***  Balanced: 6*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
2: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3]: on another proc
	destinationArray[(gnode) 4][(dof)0-3]: 44,  45,  46, 
	destinationArray[(gnode) 5][(dof)0-3]: 56,  57,  58, 
	destinationArray[(gnode) 6][(dof)0-3]: 68,  69,  70, 
	destinationArray[(gnode) 7]: on another proc
	destinationArray[(gnode) 8]: on another proc
	destinationArray[(gnode) 9]: on another proc
	destinationArray[(gnode)10]: on another proc
	destinationArray[(gnode)11][(dof)0-3]: 47,  48,  49, 
	destinationArray[(gnode)12][(dof)0-3]: 59,  60,  61, 
	destinationArray[(gnode)13][(dof)0-3]: 71,  72,  73, 
	destinationArray[(gnode)14]: on another proc
	destinationArray[(gnode)15]: on another proc
	destinationArray[(gnode)16]: on another proc
	destinationArray[(gnode)17]: on another proc
	destinationArray[(gnode)18][(dof)0-3]: 50,  51,  52, 
	destinationArray[(gnode)19][(dof)0-3]: 62,  63,  64, 
	destinationArray[(gnode)20][(dof)0-3]: 74,  75,  76, 
	destinationArray[(gnode)21]: on another proc
	destinationArray[(gnode)22]: on another proc
	destinationArray[(gnode)23]: on another proc
	destinationArray[(gnode)24]: on another proc
	destinationArray[(gnode)25][(dof)0-3]: 53,  54,  55, 
	destinationArray[(gnode)26][(dof)0-3]: 65,  66,  67, 
	destinationArray[(gnode)27][(dof)0-3]: 77,  78,  79, 
2: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/XXX]: on another proc
	LM[(g/l el) 4/ 0][(enodes)0-8]({ 0} 44, 45, 46,), ({ 1} 56, 57, 58,), ({ 4} 59, 60, 61,), ({ 3} 47, 48, 49,), ({ 6} 50, 51, 52,), ({ 7} 62, 63, 64,), ({10} 65, 66, 67,), ({ 9} 53, 54, 55,), 
	LM[(g/l el) 5/ 1][(enodes)0-8]({ 1} 56, 57, 58,), ({ 2} 68, 69, 70,), ({ 5} 71, 72, 73,), ({ 4} 59, 60, 61,), ({ 7} 62, 63, 64,), ({ 8} 74, 75, 76,), ({11} 77, 78, 79,), ({10} 65, 66, 67,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
	Node 2: 3 active dofs
	Node 3: 3 active dofs
	Node 4: 3 active dofs
	Node 5: 3 active dofs
	Node 6: 3 active dofs
	Node 7: 3 active dofs
	Node 8: 3 active dofs
	Node 9: 3 active dofs
	Node 10: 3 active dofs
	Node 11: 3 active dofs
Cleaning Up:

***  Unbalanced: 7*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
2: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3]: on another proc
	destinationArray[(gnode) 4]: on another proc
	destinationArray[(gnode) 5][(dof)0-3]: 56,  57,  58, 
	destinationArray[(gnode) 6][(dof)0-3]: 68,  69,  70, 
	destinationArray[(gnode) 7][(dof)0-3]: 80,  81,  82, 
	destinationArray[(gnode) 8]: on another proc
	destinationArray[(gnode) 9]: on another proc
	destinationArray[(gnode)10]: on another proc
	destinationArray[(gnode)11]: on another proc
	destinationArray[(gnode)12]: on another proc
	destinationArray[(gnode)13][(dof)0-3]: 59,  60,  61, 
	destinationArray[(gnode)14][(dof)0-3]: 71,  72,  73, 
	destinationArray[(gnode)15][(dof)0-3]: 83,  84,  85, 
	destinationArray[(gnode)16]: on another proc
	destinationArray[(gnode)17]: on another proc
	destinationArray[(gnode)18]: on another proc
	destinationArray[(gnode)19]: on another proc
	destinationArray[(gnode)20]: on another proc
	destinationArray[(gnode)21][(dof)0-3]: 62,  63,  64, 
	destinationArray[(gnode)22][(dof)0-3]: 74,  75,  76, 
	destinationArray[(gnode)23][(dof)0-3]: 86,  87,  88, 
	destinationArray[(gnode)24]: on another proc
	destinationArray[(gnode)25]: on another proc
	destinationArray[(gnode)26]: on another proc
	destinationArray[(gnode)27]: on another proc
	destinationArray[(gnode)28]: on another proc
	destinationArray[(gnode)29][(dof)0-3]: 65,  66,  67, 
	destinationArray[(gnode)30][(dof)0-3]: 77,  78,  79, 
	destinationArray[(gnode)31][(dof)0-3]: 89,  90,  91, 
2: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/XXX]: on another proc
	LM[(g/l el) 4/XXX]: on another proc
	LM[(g/l el) 5/ 0][(enodes)0-8]({ 0} 56, 57, 58,), ({ 1} 68, 69, 70,), ({ 4} 71, 72, 73,), ({ 3} 59, 60, 61,), ({ 6} 62, 63, 64,), ({ 7} 74, 75, 76,), ({10} 77, 78, 79,), ({ 9} 65, 66, 67,), 
	LM[(g/l el) 6/ 1][(enodes)0-8]({ 1} 68, 69, 70,), ({ 2} 80, 81, 82,), ({ 5} 83, 84, 85,), ({ 4} 71, 72, 73,), ({ 7} 74, 75, 76,), ({ 8} 86, 87, 88,), ({11} 89, 90, 91,), ({10} 77, 78, 79,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
	Node 2: 3 active dofs
	Node 3: 3 active dofs
	Node 4: 3 active dofs
	Node 5: 3 active dofs
	Node 6: 3 active dofs
	Node 7: 3 active dofs
	Node 8: 3 active dofs
	Node 9: 3 active dofs
	Node 10: 3 active dofs
	Node 11: 3 active dofs
Cleaning Up:


***  Body (Pressure) Node layout tests ***

***  Balanced: 6*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
2: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3]: on another proc
	destinationArray[(gnode) 4][(dof)0-3]: 11,  12,  13, 
	destinationArray[(gnode) 5][(dof)0-3]: 14,  15,  16, 
2: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/XXX]: on another proc
	LM[(g/l el) 4/ 0][(enodes)0-1]({ 0} 11, 12, 13,), 
	LM[(g/l el) 5/ 1][(enodes)0-1]({ 1} 14, 15, 16,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
Cleaning Up:

***  Unbalanced: 7*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
2: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3]: on another proc
	destinationArray[(gnode) 4]: on another proc
	destinationArray[(gnode) 5][(dof)0-3]: 14,  15,  16, 
	destinationArray[(gnode) 6][(dof)0-3]: 17,  18,  19, 
2: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/XXX]: on another proc
	LM[(g/l el) 4/XXX]: on another proc
	LM[(g/l el) 5/ 0][(enodes)0-1]({ 0} 14, 15, 16,), 
	LM[(g/l el) 6/ 1][(enodes)0-1]({ 1} 17, 18, 19,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
Cleaning Up:
