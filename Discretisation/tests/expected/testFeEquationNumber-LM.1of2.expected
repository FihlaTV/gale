StGermain Framework. Copyright (C) 2003-2005 VPAC.
StGermain Discretisation Library. Copyright (C) 2003-2005 VPAC.
StGermain FEM Discretisation Framework. Copyright (C) 2003-2005 VPAC.
Watching rank: 1

***  REGULAR node/element layout tests ***

***  Corner Node layout tests ***

***  Balanced: 6*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
1: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3][(dof)0-3]: 32,  33,  34, 
	destinationArray[(gnode) 4][(dof)0-3]: 44,  45,  46, 
	destinationArray[(gnode) 5][(dof)0-3]: 56,  57,  58, 
	destinationArray[(gnode) 6][(dof)0-3]: 68,  69,  70, 
	destinationArray[(gnode) 7]: on another proc
	destinationArray[(gnode) 8]: on another proc
	destinationArray[(gnode) 9]: on another proc
	destinationArray[(gnode)10][(dof)0-3]: 35,  36,  37, 
	destinationArray[(gnode)11][(dof)0-3]: 47,  48,  49, 
	destinationArray[(gnode)12][(dof)0-3]: 59,  60,  61, 
	destinationArray[(gnode)13][(dof)0-3]: 71,  72,  73, 
	destinationArray[(gnode)14]: on another proc
	destinationArray[(gnode)15]: on another proc
	destinationArray[(gnode)16]: on another proc
	destinationArray[(gnode)17][(dof)0-3]: 38,  39,  40, 
	destinationArray[(gnode)18][(dof)0-3]: 50,  51,  52, 
	destinationArray[(gnode)19][(dof)0-3]: 62,  63,  64, 
	destinationArray[(gnode)20][(dof)0-3]: 74,  75,  76, 
	destinationArray[(gnode)21]: on another proc
	destinationArray[(gnode)22]: on another proc
	destinationArray[(gnode)23]: on another proc
	destinationArray[(gnode)24][(dof)0-3]: 41,  42,  43, 
	destinationArray[(gnode)25][(dof)0-3]: 53,  54,  55, 
	destinationArray[(gnode)26][(dof)0-3]: 65,  66,  67, 
	destinationArray[(gnode)27][(dof)0-3]: 77,  78,  79, 
1: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/ 0][(enodes)0-8]({ 0} 32, 33, 34,), ({ 1} 44, 45, 46,), ({ 5} 47, 48, 49,), ({ 4} 35, 36, 37,), ({ 8} 38, 39, 40,), ({ 9} 50, 51, 52,), ({13} 53, 54, 55,), ({12} 41, 42, 43,), 
	LM[(g/l el) 4/ 1][(enodes)0-8]({ 1} 44, 45, 46,), ({ 2} 56, 57, 58,), ({ 6} 59, 60, 61,), ({ 5} 47, 48, 49,), ({ 9} 50, 51, 52,), ({10} 62, 63, 64,), ({14} 65, 66, 67,), ({13} 53, 54, 55,), 
	LM[(g/l el) 5/ 2][(enodes)0-8]({ 2} 56, 57, 58,), ({ 3} 68, 69, 70,), ({ 7} 71, 72, 73,), ({ 6} 59, 60, 61,), ({10} 62, 63, 64,), ({11} 74, 75, 76,), ({15} 77, 78, 79,), ({14} 65, 66, 67,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
	Node 2: 3 active dofs
	Node 3: 3 active dofs
	Node 4: 3 active dofs
	Node 5: 3 active dofs
	Node 6: 3 active dofs
	Node 7: 3 active dofs
	Node 8: 3 active dofs
	Node 9: 3 active dofs
	Node 10: 3 active dofs
	Node 11: 3 active dofs
	Node 12: 3 active dofs
	Node 13: 3 active dofs
	Node 14: 3 active dofs
	Node 15: 3 active dofs
Cleaning Up:

***  Unbalanced: 7*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
1: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3]: on another proc
	destinationArray[(gnode) 4][(dof)0-3]: 44,  45,  46, 
	destinationArray[(gnode) 5][(dof)0-3]: 56,  57,  58, 
	destinationArray[(gnode) 6][(dof)0-3]: 68,  69,  70, 
	destinationArray[(gnode) 7][(dof)0-3]: 80,  81,  82, 
	destinationArray[(gnode) 8]: on another proc
	destinationArray[(gnode) 9]: on another proc
	destinationArray[(gnode)10]: on another proc
	destinationArray[(gnode)11]: on another proc
	destinationArray[(gnode)12][(dof)0-3]: 47,  48,  49, 
	destinationArray[(gnode)13][(dof)0-3]: 59,  60,  61, 
	destinationArray[(gnode)14][(dof)0-3]: 71,  72,  73, 
	destinationArray[(gnode)15][(dof)0-3]: 83,  84,  85, 
	destinationArray[(gnode)16]: on another proc
	destinationArray[(gnode)17]: on another proc
	destinationArray[(gnode)18]: on another proc
	destinationArray[(gnode)19]: on another proc
	destinationArray[(gnode)20][(dof)0-3]: 50,  51,  52, 
	destinationArray[(gnode)21][(dof)0-3]: 62,  63,  64, 
	destinationArray[(gnode)22][(dof)0-3]: 74,  75,  76, 
	destinationArray[(gnode)23][(dof)0-3]: 86,  87,  88, 
	destinationArray[(gnode)24]: on another proc
	destinationArray[(gnode)25]: on another proc
	destinationArray[(gnode)26]: on another proc
	destinationArray[(gnode)27]: on another proc
	destinationArray[(gnode)28][(dof)0-3]: 53,  54,  55, 
	destinationArray[(gnode)29][(dof)0-3]: 65,  66,  67, 
	destinationArray[(gnode)30][(dof)0-3]: 77,  78,  79, 
	destinationArray[(gnode)31][(dof)0-3]: 89,  90,  91, 
1: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/XXX]: on another proc
	LM[(g/l el) 4/ 0][(enodes)0-8]({ 0} 44, 45, 46,), ({ 1} 56, 57, 58,), ({ 5} 59, 60, 61,), ({ 4} 47, 48, 49,), ({ 8} 50, 51, 52,), ({ 9} 62, 63, 64,), ({13} 65, 66, 67,), ({12} 53, 54, 55,), 
	LM[(g/l el) 5/ 1][(enodes)0-8]({ 1} 56, 57, 58,), ({ 2} 68, 69, 70,), ({ 6} 71, 72, 73,), ({ 5} 59, 60, 61,), ({ 9} 62, 63, 64,), ({10} 74, 75, 76,), ({14} 77, 78, 79,), ({13} 65, 66, 67,), 
	LM[(g/l el) 6/ 2][(enodes)0-8]({ 2} 68, 69, 70,), ({ 3} 80, 81, 82,), ({ 7} 83, 84, 85,), ({ 6} 71, 72, 73,), ({10} 74, 75, 76,), ({11} 86, 87, 88,), ({15} 89, 90, 91,), ({14} 77, 78, 79,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
	Node 2: 3 active dofs
	Node 3: 3 active dofs
	Node 4: 3 active dofs
	Node 5: 3 active dofs
	Node 6: 3 active dofs
	Node 7: 3 active dofs
	Node 8: 3 active dofs
	Node 9: 3 active dofs
	Node 10: 3 active dofs
	Node 11: 3 active dofs
	Node 12: 3 active dofs
	Node 13: 3 active dofs
	Node 14: 3 active dofs
	Node 15: 3 active dofs
Cleaning Up:


***  Body (Pressure) Node layout tests ***

***  Balanced: 6*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
1: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3][(dof)0-3]:  8,   9,  10, 
	destinationArray[(gnode) 4][(dof)0-3]: 11,  12,  13, 
	destinationArray[(gnode) 5][(dof)0-3]: 14,  15,  16, 
1: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/ 0][(enodes)0-1]({ 0}  8,  9, 10,), 
	LM[(g/l el) 4/ 1][(enodes)0-1]({ 1} 11, 12, 13,), 
	LM[(g/l el) 5/ 2][(enodes)0-1]({ 2} 14, 15, 16,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
	Node 2: 3 active dofs
Cleaning Up:

***  Unbalanced: 7*1*1 elements ***
Creating Geometry, Decomps and Layouts:
Creating F.E. Mesh:
Creating Vars:
Creating VC:
Creating EQ num:
Building:
Building mesh:
Building Variable Conditions:
Building FE Eq num:
Initialising:
Building LM:
V.C. applied: 	type: WallVC, set: Left
1: *** Printing destination array ***
	destinationArray[(gnode) 0]: on another proc
	destinationArray[(gnode) 1]: on another proc
	destinationArray[(gnode) 2]: on another proc
	destinationArray[(gnode) 3]: on another proc
	destinationArray[(gnode) 4][(dof)0-3]: 11,  12,  13, 
	destinationArray[(gnode) 5][(dof)0-3]: 14,  15,  16, 
	destinationArray[(gnode) 6][(dof)0-3]: 17,  18,  19, 
1: *** Printing location matrix ***
	LM[(g/l el) 0/XXX]: on another proc
	LM[(g/l el) 1/XXX]: on another proc
	LM[(g/l el) 2/XXX]: on another proc
	LM[(g/l el) 3/XXX]: on another proc
	LM[(g/l el) 4/ 0][(enodes)0-1]({ 0} 11, 12, 13,), 
	LM[(g/l el) 5/ 1][(enodes)0-1]({ 1} 14, 15, 16,), 
	LM[(g/l el) 6/ 2][(enodes)0-1]({ 2} 17, 18, 19,), 
Printing the counts of active EQ nums at each node:
	Node 0: 3 active dofs
	Node 1: 3 active dofs
	Node 2: 3 active dofs
Cleaning Up:
