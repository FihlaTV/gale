import os, sys
Import('env opts')

#
# Helper functions.
#

def push_paths(cpp=[], lib=[]):
    cpp = [cpp] if isinstance(cpp, str) else cpp
    lib = [lib] if isinstance(lib, str) else lib
    old = [env['CPPPATH'], env['LIBPATH']]
    env.AppendUnique(CPPPATH=cpp)
    env.AppendUnique(LIBPATH=lib)
    return old

def pop_paths(old):
    env.Replace(CPPPATH=old[0])
    env.Replace(LIBPATH=old[1])

#
# Custom configuration checks.
#

def print_result(ctx, state, libs):
    if state[0]:
        if isinstance(state[0], list):
            for d in state[0]:
                ctx.Display('      %s\n' % d)
        else:
            ctx.Display('      %s\n' % state[0])
    if state[1]:
        if isinstance(state[1], list):
            for d in state[1]:
                ctx.Display('      %s\n' % d)
        else:
            ctx.Display('      %s\n' % state[1])
    ctx.Display('   using library names:\n')
    if libs:
        if isinstance(libs, list):
            ctx.Display('      %s' % libs[0])
            for l in libs[1:]:
                ctx.Display(', %s' % l)
            ctx.Display('\n')
        else:
            ctx.Display('      %s\n' % libs)

def CheckPackage(ctx, name, check, state_gen, lib_gen):
    ctx.Message('Checking for package %s ... ' % name)

    # If options given, use that. If fails then fatal.
    for state in state_gen('options'):
        old = push_paths(state[0], state[1])
        for libs in lib_gen():
            libs = [libs] if isinstance(libs, str) else libs
            res = check(ctx, libs, state[1])
            if res:
                env['PACKAGES'][name] = (state, libs)
                ctx.Result(res)
                return res
        pop_paths(old)
        ctx.Result(res)
        ctx.Display('  invalid options\n')
        return res

    # Try and link to package with no state modification.
    for libs in lib_gen():
        libs = [libs] if isinstance(libs, str) else libs
        res = check(ctx, libs)
        if res:
            env['PACKAGES'][name] = (None, libs)
            ctx.Result(res)
            return res

    # Try and extract package location from shell environment.
    for state in state_gen('environment'):
        old = push_paths(state[0], state[1])
        for libs in lib_gen():
            libs = [libs] if isinstance(libs, str) else libs
            res = check(ctx, libs, state[1])
            if res:
                env['PACKAGES'][name] = (state, libs)
                ctx.Result(res)
                ctx.Display('   found using environment variables:\n')
                print_result(ctx, state, libs)
                return res
        pop_paths(old)

    # Cycle through default locations.
    for state in state_gen('default'):
        old = push_paths(state[0], state[1])
        for libs in lib_gen():
            libs = [libs] if isinstance(libs, str) else libs
            res = check(ctx, libs, state[1])
            if res:
                env['PACKAGES'][name] = (state, libs)
                ctx.Result(res)
                ctx.Display('   found in default location:\n')
                print_result(ctx, state, libs)
                return res
        pop_paths(old)

    ctx.Result(res)

def CheckFortranSymbol(ctx):
    fSrc = """
      Program Conftest
      external method
      integer i
      call method(i)
      stop
      end
"""
    cSrc = """
#include <stdio.h>
void method(int *i){printf("FORTRAN_NORMAL");}
void method_(int *i){printf("FORTRAN_SINGLE_TRAILINGBAR");}
void method__(int *i){printf("FORTRAN_DOUBLE_TRAILINGBAR");}
void METHOD(int *i){printf("FORTRAN_UPPERCASE");}
"""
    ctx.Message('Checking for fortran symbol type... ')

    res = ctx.TryCompile(cSrc, '.c')
    if not res:
        ctx.Result(res)
        return res
    cObj = ctx.lastTarget

    oldLINK = env['LINK'] if 'LINK' in env._dict else None
    oldLINKFLAGS = env['LINKFLAGS'] if 'LINKFLAGS' in env._dict else None
    oldLIBS = env['LIBS'] if 'LIBS' in env._dict else None
    env['LINK'] = env['_FORTRAND']
    env['LINKFLAGS'] = str(cObj)
    env['LIBS'] = []
    res = ctx.TryRun(fSrc, '.F')
    env['LINK'] = oldLINK
    env['LINKFLAGS'] = oldLINKFLAGS
    env['LIBS'] = oldLIBS
    if not res[0]:
        ctx.Result(res[0])
        return res[0]

    env.Append(CPPDEFINES=[res[1]])
    ctx.Result(res[0])
    return res[0]

#
# Package configuration generators.
#

## MPICH ##

def mpich_state_gen(type):
    if type == 'options':
        if 'mpichDir' in env._dict:
            yield (os.path.join(env['mpichDir'], 'include'),
                   os.path.join(env['mpichDir'], 'lib'))
        elif 'mpichLibDir' in env._dict or 'mpichIncDir' in env._dict:
            inc = env['mpichIncDir'] if 'mpichIncDir' in env._dict else None
            lib = env['mpichLibDir'] if 'mpichLibDir' in env._dict else None
            yield (inc, lib)
    elif type == 'environment':
        if 'MPI_DIR' in env['ENV']:
            yield (os.path.join(env['ENV']['MPI_DIR'], 'include'),
                   os.path.join(env['ENV']['MPI_DIR'], 'lib'))
    elif type == 'default':
        yield ('/usr/include/mpich', '/usr/lib')
        yield ('/usr/local/mpich/include', '/usr/local/mpich/lib')

def mpich_lib_gen():
    yield ['mpich']
    yield ['pmpich']
    yield ['mpich', 'pmpich']
    yield ['mpich', 'rt']
    yield ['pmpich', 'rt']
    yield ['mpich', 'pmpich', 'rt']

def check_mpich(ctx, libs, libpath=None):
    src = """
#include<mpi.h>
int main(int argc, char** argv) {
MPI_Init(&argc, &argv);
MPI_Finalize();
return (MPI_VERSION == 2) ? 0 : 1;
}
"""
    old = env['LIBS'], env['RPATH']
    env.Replace(LIBS=libs)
    env.Replace(RPATH=libpath)
    res = ctx.TryRun(src, '.c')[0]
    env.Replace(LIBS=old[0])
    env.Replace(RPATH=old[1])
    if not res:
        return res

    env.AppendUnique(LIBS=libs)
    return res

## libXML2 ##

def libxml2_state_gen(type):
    if type == 'options':
        if 'libxml2Dir' in env._dict:
            yield (os.path.join(env['libxml2Dir'], 'include'),
                   os.path.join(env['libxml2Dir'], 'lib'))
        elif 'libxml2LibDir' in env._dict or 'libxml2IncDir' in env._dict:
            inc = env['libxml2IncDir'] \
                if 'libxml2IncDir' in env._dict else None
            lib = env['libxml2LibDir'] \
                if 'libxml2LibDir' in env._dict else None
            yield (inc, lib)
    elif type == 'environment':
        if 'LIBXML2_DIR' in env['ENV']:
            yield (os.path.join(env['ENV']['LIBXML2_DIR'], 'include'),
                   os.path.join(env['ENV']['LIBXML2_DIR'], 'lib'))
    elif type == 'default':
        yield ('/usr/include/libxml2', None)
        yield ('/usr/include/libxml2', '/usr/lib')
        yield ('/usr/local/libxml2/include', '/usr/local/libxml2/lib')

def libxml2_lib_gen():
    yield ['libxml2']

def check_libxml2(ctx, libs, libpath=None):
    src = """
#include<libxml/xmlIO.h>
int main(int argc, char** argv) {
return 0;
}
"""
    old = env['LIBS']
    env.Replace(LIBS=libs)
    res = ctx.TryLink(src, '.c')
    env.Replace(LIBS=old)
    if not res:
        return res

    env.AppendUnique(LIBS=libs)
    return res

## StGermain ##

def stgermain_state_gen(type):
    if type == 'options':
        if 'stgermainDir' in env._dict:
            yield (os.path.join(env['stgermainDir'], 'include'),
                   os.path.join(env['stgermainDir'], 'lib'))
        elif 'stgermainLibDir' in env._dict or 'stgermainIncDir' in env._dict:
            inc = env['stgermainIncDir'] \
                if 'stgermainIncDir' in env._dict else None
            lib = env['stgermainLibDir'] \
                if 'stgermainLibDir' in env._dict else None
            yield (inc, lib)
    elif type == 'environment':
        if 'STGERMAIN_DIR' in env['ENV']:
            yield (os.path.join(env['ENV']['STGERMAIN_DIR'], 'include'),
                   os.path.join(env['ENV']['STGERMAIN_DIR'], 'lib'))
    elif type == 'default':
        yield ('../StGermain/build/include', '../StGermain/build/lib')

def stgermain_lib_gen():
    yield ['StGermain']

def check_stgermain(ctx, libs, libpath=None):
    src = """
#include<StGermain/StGermain.h>
int main(int argc, char** argv) {
StGermain_Init(&argc, &argv);
StGermain_Finalise();
return 0;
}
"""
    old = env['LIBS']
    env.Replace(LIBS=libs)
    res = ctx.TryLink(src, '.c')
    env.Replace(LIBS=old)
    if not res:
        return res

    env.AppendUnique(LIBS=libs)
    return res

## lapack ##

def lapack_state_gen(type):
    if type == 'options':
        if 'lapackDir' in env._dict:
            yield (None, os.path.join(env['lapackDir'], 'lib'))
        elif 'lapackLibDir' in env._dict:
            yield (None, env['lapackLibDir'])
    elif type == 'environment':
        if 'LAPACK_DIR' in env['ENV']:
            yield (None, os.path.join(env['ENV']['LAPACK_DIR'], 'lib'))
        if 'LAPACK_LIB_DIR' in env['ENV']:
            yield (None, env['ENV']['LAPACK_LIB_DIR'])
    elif type == 'default':
        yield (None, '/usr/lib')

def lapack_lib_gen():
    yield ['lapack']

def check_lapack(ctx, libs):
    src = """
int main(int argc, char** argv) {
return 0;
}
"""
    old = env['LIBS']
    env.Replace(LIBS=libs)
    res = ctx.TryLink(src, '.c')
    env.Replace(LIBS=old)
    if not res:
        return res

    env.AppendUnique(LIBS=libs)
    return res

#
# Do configuration.
#

if not env.GetOption('clean'):
    cfg = Configure(env,
                    custom_tests={'CheckFortranSymbol':
                                      CheckFortranSymbol,
                                  'CheckPackage':
                                      CheckPackage})

    # Add a member to 'env' for storing package results.
    env['PACKAGES'] = {}

    #
    # Check for the C math library.
    #

    if not cfg.CheckLib('m'):
        print "Couldn't find the C standard math libaray."
        env.Exit()

    #
    #
    #

    if not cfg.CheckPackage('MPICH', check_mpich,
                            mpich_state_gen, mpich_lib_gen):
        env.Exit()
    opts.Save('config.cache', env)

    #
    # Check for libXML2.
    #

    if not cfg.CheckPackage('libXML2', check_libxml2,
                            libxml2_state_gen, libxml2_lib_gen):
        env.Exit()
    opts.Save('config.cache', env)

    #
    # Check for an implementation of lapack
    #

    if not cfg.CheckPackage('lapack', check_lapack,
                            lapack_state_gen, lapack_lib_gen):
        env.Exit()
    opts.Save('config.cache', env)

    #
    # Check for StGermain.
    #

    if not cfg.CheckPackage('StGermain', check_stgermain,
                            stgermain_state_gen, stgermain_lib_gen):
        env.Exit()
    opts.Save('config.cache', env)

    #
    # Check Fortran symbol type.
    #

    if not cfg.CheckFortranSymbol():
        print 'Fortran symbol check failed.'
        env.Exit()

    #
    # Extract revision number.
    #

    svnPath = os.path.join('.svn', 'entries')
    if not os.path.exists(svnPath):
        print "\nYou appear to be building the code from something"
        print "that wasn't checked out of a repository. Bummer."
        env.Exit()
    f = file(svnPath, 'r')
    f.readline()
    f.readline()
    f.readline()
    ver = env['ESCAPE']('"' + str(int(f.readline())) + '"')
    env.Append(CPPDEFINES=[('VERSION', ver)])
    f.close()

    #
    # Add module extension to build commands.
    #

    ext = env['ESCAPE']('"' + env['SHLIBSUFFIX'][1:] + '"')
    env.Append(CPPDEFINES=[('MODULE_EXT', ext)])

    #
    # Add the library directory.
    #

    libDir = os.path.join(Dir('.').abspath, 'build', 'lib')
    libDir = env['ESCAPE']('"' + libDir + '"')
    env.Append(CPPDEFINES=[('LIB_DIR', libDir)])

    #
    # Setup the dynamic library search paths.
    #

    env.Append(RPATH=[os.path.join(Dir('.').abspath, 'build', 'lib')])

    env = cfg.Finish()
